# 正则表达式

标签（空格分隔）： 正则表达式 分享会

---
# 原理
---
## 1、编译
- 创建（正则直接量 或 构造函数 ）=> 浏览器引擎解析转换为原生代码程序

- 解析和转换在创建的时候都会发生（但！浏览器内部会有一些优化😲！！）

> 优化：浏览器缓存编译结果 ，比如把正则对象赋值给变量，不重复执行这一个过程
> 
> 但是不能只指望每个浏览器都这么能干  =>  复杂的表达式可进行 **预定义(预编译)**

## 2、设置初始位置
- 当正则类进入使用状态，要确定目标字符串的起始搜索位置, 这个位置是 **字符串起始字符**， 或是 **正则的lastIndex**， 但当它从第四步匹配失败返回时，这个位置则是最后一次匹配的起始位置的下一个字符

- 优化： 浏览器优化。
> 以 **^** 开头的表示式，则直接判断字符串的起始字符
> 匹配第三字符是 X 的字符串， 则是先找到 X，再回退两个字符
> 所以，编写时，最理想是，一个表达式的起始标记尽可能能快速测试（明确），如使用**^ 、$、特定字符**

## 3、匹配每个正则表达式字元
- 逐个检查文本和正则表达式模式。 
- 一个特定字元匹配失败，**回溯**到之前尝试匹配的位置上，**尝试其他可能路径**
- **回溯** 特么是哪个幼儿园的？

## 4、匹配成功或失败
- 成功： 字符串当前位置发现一个完全匹配
- 失败： 回退到第二步，然后从下一个字符重新尝试，重复

---
# 回溯
---
> 匹配过程，正则从左到右测试，看能否找到匹配项。 遇到 **量词 和 分支** ，需要**决策**下一步如和处理。（决策点）
**量词**： *、？、{2，} ...
**分支**： (ext) **|** (EXT)

> 当正则表达式做类似决定时，如果有必要，都会记录其他选择，以便返回时使用.
在当前匹配项匹配失败时，或者后面的部分匹配失败，那么 正则会 **回溯** 到最后一个**决策点**，    

> 然后在剩余选项中选择一个。就这样会一直重复，直到找到匹配项，或者**量词和分支**选项都尝试失败

> 回溯是匹配过程的基础组成部分， 可是hin厉害的噢~

> 但是，回溯会产生昂贵的计算消耗，一不小心会失控。

### 分支回溯
```javascript
var Reg = /K(imZ|ing) wow/
Reg.test('KimZ WW, King wow')

```
### 重复回溯
```javascript
var Reg1 = /<a>.*<\/a>/
var Reg2 = /<a>.*?<\/a>/

var html = '<a> link </a>' +
            '<span> span </span>'+
            '<a> link2 </a>'+
            '<div> div </div>'
            
Reg1.exec(html)
Reg2.exec(html)
```
> 贪婪量词 ```*```   ：尽可能多的匹配 => 一口吃掉整个字符串，匹配 <
> 惰性量词 ```*?``` ：尽可能少 => 最小重复次数 0

---
### 回溯失控

```
/<html>[\s\S]*?<head>[\s\S]*?<title>[\s\S]*?</title>[\s\S]*?</head>[\s\S]*?<body>[\s\S]*?</body>[\s\S]*?</html>/
```
```
 .*            : 除换行符
 [\s\S]*       : 任意字符
 (?:.|\s)*     : ？？？
```
以上表达式匹配常规html字符是正常的
但是，假如缺少其中列出的必要标签，就。。。🙂
（接下来是过程，《高性能》原话）
比如最后的 ```</html> ```, 缺少它的时候，最后一个 ```[\s\S]*?```将拓展到字符串末尾，因为仍然没有找到```</html> ```，正则表达式不会放弃（就像是具有坚强意志的灰太狼先生），而是**依次向前搜索**```[\s\S]*?```并**记住回溯的位置**以便后续使用。

正则表达式尝试拓展到倒数第二个```[\s\S]*?```————用它匹配由正则表达式的```</body>```模式匹配到的那个```</body>```标签————然后继续查找第二个```</body>```标签, 直到字符串末尾。匹配失败后，轮到倒数第三个```[\s\S]*?```拓展到结尾。以此类推...

---
### 原子组
> **(?> ...)** ： 原子组存在一个正则表达式，该组的任何**回溯位置**都会**被丢弃**
<br>
#### 预查
> **(?= ...)** ： 预查作为全局匹配的一部分，并**不消耗任何字符**，只是检查自己包含的正则符号在当前字符串是否匹配

```javascript

r = /Jack(?=Sprat)/
// 如果"Jack"后面跟着"Sprat"，则匹配之。但是，"Sprat"  都不会在匹配结果中出现。
r.exec('JackSprat')

```
那我们在JackSprat加个88
```javascript
r = /Jack(?=Sprat)88/

r.exec('JackSprat88')

```
<br>
#### 捕获 & 反向引用

> **捕获**： **(...)** 括号

> **反向引用**： \Number, Number为要引用的捕获

```javascript
比较一下：
r = /^([abc])O\1/
r1 = /^([abc])O[abc]/

```
让我们 **“回溯”** 到刚刚的88问题

```javascript
r = /Jack(?=(Sprat))\1(88)/

r.exec('JackSprat88')

```
> 反向引用重新匹配预查过程发现的字符，将其作为实际匹配的一部分

----
### （假）原子组

> **(?=(pattern))\1**

所以我们有这样的代码🙄：
```javascript
// <html (?:[\s|\S]*?)>(?=([\s|\S]*?<head>))\1

/<html> (?=([\s|\S]*?<head>))\1 (?=([\s|\S]*?<title>))\2 (?=([\s|\S]*?</title>))\3 (?=([\s|\S]*?</head>))\4 (?=([\s|\S]*?<body>))\5 (?=([\s|\S]*?</body>))\6 [\s|\S]*?</html>/

```
这个表达式每找到一个中间就会**退出**一个**预查**，它在预查的过程丢弃所有回溯位置。反向引用则是重新匹配预查过程发现的字符，将其作为实际匹配的一部分。

缺少 ```</html>```, 最后一个```[\s|\S]*?```展开至字符串末尾，匹配失败，立刻宣布完全匹配失败，因为**没有可回溯的回溯点**。 

---
参考：
- 高性能JavaScript
- JavaScript忍者秘籍
- [可视化工具](https://regexper.com/)